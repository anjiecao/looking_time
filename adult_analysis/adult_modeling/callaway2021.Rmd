---
title: "callaway2021"
author: "anjie"
date: "4/19/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(here)
```

We consider simple choice problems in which a decision maker (DM) is presented with a set of items (e.g., snacks) and must choose one. 
- $i$: item
- $u^{(i)}$: the utility that the DM would gain by choosing it 


DM's belief about the item values at time t is described by a set of Gaussians, one for each item
- $\mu^{(i)}_{t}$: means of the gaussian 
- $\lambda^{(i)}_{t}$: the precision is the inverse of the variance 

these estimated value distributions are initialized to the DM's prior belief about the distribution of values in the environment. that is, she assummes that: 

$u^{(i)} ~ \sim Gaussians(\overline{\mu}, \overline{\sigma }^{2})$

and consequently set 

$\mu^{(i)}_{0} = \overline{\mu}$
$\lambda^{(i)}_{0} = \overline{\sigma }^{2}$

for all i. 

We model the control of attention as the selection of cognitive operations, $c_{t}$ that specify either an item to sample, or the termination of sampling. if the DM wishes to sample from item c at tiem-step t. she selects $c_{t} = c$ and receives a signal 


```{r}

unknown_true_value_for_c = 0
fp_amount_of_noise = 1

signal_for_c = rnorm(100, 
                     unknown_true_value_for_c, 
                     fp_amount_of_noise ^ 2)


hist(signal_for_c)
```

```{r}
percision_at_time_t0 = 0.2
utility_at_t0 = .1

precision_at_t1 = percision_at_time_t0 + fp_amount_of_noise ^ (-2)
utilitiy_at_t1 = (fp_amount_of_noise ^ (-2) * sample(signal_for_c, 1) + percision_at_time_t0 * utility_at_t0) / precision_at_t1

precision_at_t1
utilitiy_at_t1
  
```




# need to better understand the relationship betwee noise in the signal and the estimated precision etc 


```{r}
# belief about the item 
b_mu = 1
b_variance = 0.2 
b_precision = 1/b_variance 

b_prior_distribution = rnorm(100, 
                b_mu, 
                b_variance)
b_prior = sample(b_prior_distribution, 1)


# signal received after choosing the item 
s_mu = 0.8 # unknown true value of item being sampled 
s_variance = 0.1 # the amount of noise in each signal 
s_precision = 1/s_variance

s_x_distribution = rnorm(100, 
                       s_mu, 
                       s_variance)
s_x = sample(s_x_distribution, 1)

# update the belief after receiving the item 
b_new_precision = b_precision + s_precision 
b_posterior = ((s_precision * s_x) + (b_precision * b_prior)) / b_new_precision




```

```{r}
update_precision <- function(prior_belief_precision, 
                             signal_precision){
  return (prior_belief_precision + signal_precision)
}

update_belief <- function(signal_precision, 
                          signal_value, 
                          belief_precision, 
                          belief_value, 
                          updated_signal_precision){
  
  updated_belief <- ((signal_precision * signal_value) + 
                       (belief_precision * belief_value)) / updated_signal_precision
  
  return (updated_belief)

}


```



```{r}

# belief about the item 
b_mu = .2
b_variance = 0.2 
b_precision = 1/b_variance 

b_prior_distribution = rnorm(100, 
                b_mu, 
                b_variance)
b_prior = sample(b_prior_distribution, 1)


# signal received after choosing the item 
s_mu = 5 # unknown true value of item being sampled 
s_variance = 0.1 # the amount of noise in each signal 
s_precision = 1/s_variance

s_x_distribution = rnorm(100, 
                       s_mu, 
                       s_variance)
s_x = sample(s_x_distribution, 1)

# pretend to have 100 time points 
belief_precision_vector <- c(b_precision)
belief_mu_vector <- c(b_mu)

for (i in 1:100){
  
  current_belief_precision = belief_precision_vector[i]
  current_belief_mu = belief_mu_vector[i]
  
  updated_belief_precision = update_precision(current_belief_precision, 
                                       s_precision)
  
  updated_mu = update_belief(s_precision,
                             s_x, 
                             current_belief_precision, 
                             current_belief_mu, 
                             updated_belief_precision)
  
  belief_precision_vector <- c(belief_precision_vector, updated_belief_precision)
  belief_mu_vector <- c(belief_mu_vector, updated_mu)
  
}

tibble("time_point" = seq(1, 101, 1),
       "belief" = belief_mu_vector, 
       "precision" = belief_precision_vector, 
)
```


# Metalevel markov decision process 
```{r}

```




